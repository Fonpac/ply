Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement other_statement
Rule 2     statement -> assign
Rule 3     statement -> expression
Rule 4     statement -> if
Rule 5     assign -> IDENTIFIER EQUALS expression
Rule 6     other_statement -> statement other_statement
Rule 7     other_statement -> empty
Rule 8     expression -> num_expression
Rule 9     expression -> bool_expression
Rule 10    expression -> func
Rule 11    expression -> call_func
Rule 12    bool_expression -> BOOL
Rule 13    bool_expression -> NOT bool_expression
Rule 14    bool_expression -> num_expression REL_OP num_expression
Rule 15    bool_expression -> bool_expression AND_OR bool_expression
Rule 16    bool_expression -> OPEN_PAR bool_expression CLOSE_PAR
Rule 17    bool_expression -> COLON IDENTIFIER
Rule 18    num_expression -> num_expression PLUS num_expression
Rule 19    num_expression -> num_expression MINUS num_expression
Rule 20    num_expression -> num_expression TIMES num_expression
Rule 21    num_expression -> num_expression DIVIDE num_expression
Rule 22    num_expression -> num_expression POWER num_expression
Rule 23    num_expression -> OPEN_PAR num_expression CLOSE_PAR
Rule 24    num_expression -> MINUS num_expression
Rule 25    num_expression -> NUM
Rule 26    num_expression -> COLON IDENTIFIER
Rule 27    func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
Rule 28    opt_args -> IDENTIFIER opt_args
Rule 29    opt_args -> empty
Rule 30    opt_params -> expression opt_params
Rule 31    opt_params -> empty
Rule 32    call_func -> IDENTIFIER opt_params
Rule 33    if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
Rule 34    possible_else -> ELSE statement END
Rule 35    possible_else -> empty
Rule 36    empty -> <empty>

Terminals, with rules where they appear

AND_OR               : 15
BOOL                 : 12
CLOSE_PAR            : 16 23 27 33
COLON                : 17 26
DIVIDE               : 21
ELSE                 : 34
END                  : 27 33 34
EQUALS               : 5
IDENTIFIER           : 5 17 26 27 28 32
IF                   : 33
MINUS                : 19 24
NOT                  : 13
NUM                  : 25
OPEN_PAR             : 16 23 27 33
PLUS                 : 18
POWER                : 22
REL_OP               : 14
THEN                 : 33
TIMES                : 20
TO                   : 27
error                : 

Nonterminals, with rules where they appear

assign               : 2
bool_expression      : 9 13 15 15 16 33
call_func            : 11
empty                : 7 29 31 35
expression           : 3 5 30
func                 : 10
if                   : 4
num_expression       : 8 14 14 18 18 19 19 20 20 21 21 22 22 23 24
opt_args             : 27 28
opt_params           : 30 32
other_statement      : 1 6
possible_else        : 33
program              : 27 0
statement            : 1 6 33 34

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement other_statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    program                        shift and go to state 1
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> statement . other_statement
    (6) other_statement -> . statement other_statement
    (7) other_statement -> . empty
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (36) empty -> .
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    $end            reduce using rule 36 (empty -> .)
    END             reduce using rule 36 (empty -> .)
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    statement                      shift and go to state 19
    other_statement                shift and go to state 20
    empty                          shift and go to state 21
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 3

    (2) statement -> assign .

    IDENTIFIER      reduce using rule 2 (statement -> assign .)
    IF              reduce using rule 2 (statement -> assign .)
    OPEN_PAR        reduce using rule 2 (statement -> assign .)
    MINUS           reduce using rule 2 (statement -> assign .)
    NUM             reduce using rule 2 (statement -> assign .)
    COLON           reduce using rule 2 (statement -> assign .)
    BOOL            reduce using rule 2 (statement -> assign .)
    NOT             reduce using rule 2 (statement -> assign .)
    TO              reduce using rule 2 (statement -> assign .)
    $end            reduce using rule 2 (statement -> assign .)
    END             reduce using rule 2 (statement -> assign .)
    ELSE            reduce using rule 2 (statement -> assign .)


state 4

    (3) statement -> expression .

    IDENTIFIER      reduce using rule 3 (statement -> expression .)
    IF              reduce using rule 3 (statement -> expression .)
    OPEN_PAR        reduce using rule 3 (statement -> expression .)
    MINUS           reduce using rule 3 (statement -> expression .)
    NUM             reduce using rule 3 (statement -> expression .)
    COLON           reduce using rule 3 (statement -> expression .)
    BOOL            reduce using rule 3 (statement -> expression .)
    NOT             reduce using rule 3 (statement -> expression .)
    TO              reduce using rule 3 (statement -> expression .)
    $end            reduce using rule 3 (statement -> expression .)
    END             reduce using rule 3 (statement -> expression .)
    ELSE            reduce using rule 3 (statement -> expression .)


state 5

    (4) statement -> if .

    IDENTIFIER      reduce using rule 4 (statement -> if .)
    IF              reduce using rule 4 (statement -> if .)
    OPEN_PAR        reduce using rule 4 (statement -> if .)
    MINUS           reduce using rule 4 (statement -> if .)
    NUM             reduce using rule 4 (statement -> if .)
    COLON           reduce using rule 4 (statement -> if .)
    BOOL            reduce using rule 4 (statement -> if .)
    NOT             reduce using rule 4 (statement -> if .)
    TO              reduce using rule 4 (statement -> if .)
    $end            reduce using rule 4 (statement -> if .)
    END             reduce using rule 4 (statement -> if .)
    ELSE            reduce using rule 4 (statement -> if .)


state 6

    (5) assign -> IDENTIFIER . EQUALS expression
    (32) call_func -> IDENTIFIER . opt_params
    (30) opt_params -> . expression opt_params
    (31) opt_params -> . empty
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (36) empty -> .
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    EQUALS          shift and go to state 23
    IF              reduce using rule 36 (empty -> .)
    $end            reduce using rule 36 (empty -> .)
    END             reduce using rule 36 (empty -> .)
    ELSE            reduce using rule 36 (empty -> .)
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18
    IDENTIFIER      shift and go to state 22

  ! IDENTIFIER      [ reduce using rule 36 (empty -> .) ]
  ! OPEN_PAR        [ reduce using rule 36 (empty -> .) ]
  ! MINUS           [ reduce using rule 36 (empty -> .) ]
  ! NUM             [ reduce using rule 36 (empty -> .) ]
  ! COLON           [ reduce using rule 36 (empty -> .) ]
  ! BOOL            [ reduce using rule 36 (empty -> .) ]
  ! NOT             [ reduce using rule 36 (empty -> .) ]
  ! TO              [ reduce using rule 36 (empty -> .) ]

    expression                     shift and go to state 24
    opt_params                     shift and go to state 25
    empty                          shift and go to state 26
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 7

    (8) expression -> num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression
    (14) bool_expression -> num_expression . REL_OP num_expression

  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 8 (expression -> num_expression .)
    IF              reduce using rule 8 (expression -> num_expression .)
    OPEN_PAR        reduce using rule 8 (expression -> num_expression .)
    NUM             reduce using rule 8 (expression -> num_expression .)
    COLON           reduce using rule 8 (expression -> num_expression .)
    BOOL            reduce using rule 8 (expression -> num_expression .)
    NOT             reduce using rule 8 (expression -> num_expression .)
    TO              reduce using rule 8 (expression -> num_expression .)
    $end            reduce using rule 8 (expression -> num_expression .)
    END             reduce using rule 8 (expression -> num_expression .)
    ELSE            reduce using rule 8 (expression -> num_expression .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31
    REL_OP          shift and go to state 32

  ! MINUS           [ reduce using rule 8 (expression -> num_expression .) ]


state 8

    (9) expression -> bool_expression .
    (15) bool_expression -> bool_expression . AND_OR bool_expression

    IDENTIFIER      reduce using rule 9 (expression -> bool_expression .)
    IF              reduce using rule 9 (expression -> bool_expression .)
    OPEN_PAR        reduce using rule 9 (expression -> bool_expression .)
    MINUS           reduce using rule 9 (expression -> bool_expression .)
    NUM             reduce using rule 9 (expression -> bool_expression .)
    COLON           reduce using rule 9 (expression -> bool_expression .)
    BOOL            reduce using rule 9 (expression -> bool_expression .)
    NOT             reduce using rule 9 (expression -> bool_expression .)
    TO              reduce using rule 9 (expression -> bool_expression .)
    $end            reduce using rule 9 (expression -> bool_expression .)
    END             reduce using rule 9 (expression -> bool_expression .)
    ELSE            reduce using rule 9 (expression -> bool_expression .)
    AND_OR          shift and go to state 33


state 9

    (10) expression -> func .

    IDENTIFIER      reduce using rule 10 (expression -> func .)
    IF              reduce using rule 10 (expression -> func .)
    OPEN_PAR        reduce using rule 10 (expression -> func .)
    MINUS           reduce using rule 10 (expression -> func .)
    NUM             reduce using rule 10 (expression -> func .)
    COLON           reduce using rule 10 (expression -> func .)
    BOOL            reduce using rule 10 (expression -> func .)
    NOT             reduce using rule 10 (expression -> func .)
    TO              reduce using rule 10 (expression -> func .)
    $end            reduce using rule 10 (expression -> func .)
    END             reduce using rule 10 (expression -> func .)
    ELSE            reduce using rule 10 (expression -> func .)


state 10

    (11) expression -> call_func .

    IDENTIFIER      reduce using rule 11 (expression -> call_func .)
    IF              reduce using rule 11 (expression -> call_func .)
    OPEN_PAR        reduce using rule 11 (expression -> call_func .)
    MINUS           reduce using rule 11 (expression -> call_func .)
    NUM             reduce using rule 11 (expression -> call_func .)
    COLON           reduce using rule 11 (expression -> call_func .)
    BOOL            reduce using rule 11 (expression -> call_func .)
    NOT             reduce using rule 11 (expression -> call_func .)
    TO              reduce using rule 11 (expression -> call_func .)
    $end            reduce using rule 11 (expression -> call_func .)
    END             reduce using rule 11 (expression -> call_func .)
    ELSE            reduce using rule 11 (expression -> call_func .)


state 11

    (33) if -> IF . OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END

    OPEN_PAR        shift and go to state 34


state 12

    (23) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (16) bool_expression -> OPEN_PAR . bool_expression CLOSE_PAR
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17

    num_expression                 shift and go to state 35
    bool_expression                shift and go to state 36

state 13

    (24) num_expression -> MINUS . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 37

state 14

    (25) num_expression -> NUM .

    PLUS            reduce using rule 25 (num_expression -> NUM .)
    MINUS           reduce using rule 25 (num_expression -> NUM .)
    TIMES           reduce using rule 25 (num_expression -> NUM .)
    DIVIDE          reduce using rule 25 (num_expression -> NUM .)
    POWER           reduce using rule 25 (num_expression -> NUM .)
    REL_OP          reduce using rule 25 (num_expression -> NUM .)
    IDENTIFIER      reduce using rule 25 (num_expression -> NUM .)
    IF              reduce using rule 25 (num_expression -> NUM .)
    OPEN_PAR        reduce using rule 25 (num_expression -> NUM .)
    NUM             reduce using rule 25 (num_expression -> NUM .)
    COLON           reduce using rule 25 (num_expression -> NUM .)
    BOOL            reduce using rule 25 (num_expression -> NUM .)
    NOT             reduce using rule 25 (num_expression -> NUM .)
    TO              reduce using rule 25 (num_expression -> NUM .)
    $end            reduce using rule 25 (num_expression -> NUM .)
    END             reduce using rule 25 (num_expression -> NUM .)
    ELSE            reduce using rule 25 (num_expression -> NUM .)
    CLOSE_PAR       reduce using rule 25 (num_expression -> NUM .)
    AND_OR          reduce using rule 25 (num_expression -> NUM .)


state 15

    (26) num_expression -> COLON . IDENTIFIER
    (17) bool_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 40


state 16

    (12) bool_expression -> BOOL .

    AND_OR          reduce using rule 12 (bool_expression -> BOOL .)
    IDENTIFIER      reduce using rule 12 (bool_expression -> BOOL .)
    IF              reduce using rule 12 (bool_expression -> BOOL .)
    OPEN_PAR        reduce using rule 12 (bool_expression -> BOOL .)
    MINUS           reduce using rule 12 (bool_expression -> BOOL .)
    NUM             reduce using rule 12 (bool_expression -> BOOL .)
    COLON           reduce using rule 12 (bool_expression -> BOOL .)
    BOOL            reduce using rule 12 (bool_expression -> BOOL .)
    NOT             reduce using rule 12 (bool_expression -> BOOL .)
    TO              reduce using rule 12 (bool_expression -> BOOL .)
    $end            reduce using rule 12 (bool_expression -> BOOL .)
    END             reduce using rule 12 (bool_expression -> BOOL .)
    ELSE            reduce using rule 12 (bool_expression -> BOOL .)
    CLOSE_PAR       reduce using rule 12 (bool_expression -> BOOL .)


state 17

    (13) bool_expression -> NOT . bool_expression
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    OPEN_PAR        shift and go to state 43
    COLON           shift and go to state 44
    MINUS           shift and go to state 13
    NUM             shift and go to state 14

    bool_expression                shift and go to state 41
    num_expression                 shift and go to state 42

state 18

    (27) func -> TO . IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END

    IDENTIFIER      shift and go to state 45


state 19

    (6) other_statement -> statement . other_statement
    (6) other_statement -> . statement other_statement
    (7) other_statement -> . empty
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (36) empty -> .
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    $end            reduce using rule 36 (empty -> .)
    END             reduce using rule 36 (empty -> .)
    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    statement                      shift and go to state 19
    other_statement                shift and go to state 46
    empty                          shift and go to state 21
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 20

    (1) program -> statement other_statement .

    $end            reduce using rule 1 (program -> statement other_statement .)
    END             reduce using rule 1 (program -> statement other_statement .)


state 21

    (7) other_statement -> empty .

    $end            reduce using rule 7 (other_statement -> empty .)
    END             reduce using rule 7 (other_statement -> empty .)


state 22

    (32) call_func -> IDENTIFIER . opt_params
    (30) opt_params -> . expression opt_params
    (31) opt_params -> . empty
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (36) empty -> .
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IF              reduce using rule 36 (empty -> .)
    $end            reduce using rule 36 (empty -> .)
    END             reduce using rule 36 (empty -> .)
    ELSE            reduce using rule 36 (empty -> .)
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18
    IDENTIFIER      shift and go to state 22

  ! OPEN_PAR        [ reduce using rule 36 (empty -> .) ]
  ! MINUS           [ reduce using rule 36 (empty -> .) ]
  ! NUM             [ reduce using rule 36 (empty -> .) ]
  ! COLON           [ reduce using rule 36 (empty -> .) ]
  ! BOOL            [ reduce using rule 36 (empty -> .) ]
  ! NOT             [ reduce using rule 36 (empty -> .) ]
  ! TO              [ reduce using rule 36 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 36 (empty -> .) ]

    opt_params                     shift and go to state 25
    expression                     shift and go to state 24
    empty                          shift and go to state 26
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 23

    (5) assign -> IDENTIFIER EQUALS . expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18
    IDENTIFIER      shift and go to state 22

    expression                     shift and go to state 47
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 24

    (30) opt_params -> expression . opt_params
    (30) opt_params -> . expression opt_params
    (31) opt_params -> . empty
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (36) empty -> .
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IF              reduce using rule 36 (empty -> .)
    $end            reduce using rule 36 (empty -> .)
    END             reduce using rule 36 (empty -> .)
    ELSE            reduce using rule 36 (empty -> .)
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18
    IDENTIFIER      shift and go to state 22

  ! OPEN_PAR        [ reduce using rule 36 (empty -> .) ]
  ! MINUS           [ reduce using rule 36 (empty -> .) ]
  ! NUM             [ reduce using rule 36 (empty -> .) ]
  ! COLON           [ reduce using rule 36 (empty -> .) ]
  ! BOOL            [ reduce using rule 36 (empty -> .) ]
  ! NOT             [ reduce using rule 36 (empty -> .) ]
  ! TO              [ reduce using rule 36 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 36 (empty -> .) ]

    expression                     shift and go to state 24
    opt_params                     shift and go to state 48
    empty                          shift and go to state 26
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 25

    (32) call_func -> IDENTIFIER opt_params .

    IDENTIFIER      reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    IF              reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    OPEN_PAR        reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    MINUS           reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    NUM             reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    COLON           reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    BOOL            reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    NOT             reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    TO              reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    $end            reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    END             reduce using rule 32 (call_func -> IDENTIFIER opt_params .)
    ELSE            reduce using rule 32 (call_func -> IDENTIFIER opt_params .)


state 26

    (31) opt_params -> empty .

    IDENTIFIER      reduce using rule 31 (opt_params -> empty .)
    IF              reduce using rule 31 (opt_params -> empty .)
    OPEN_PAR        reduce using rule 31 (opt_params -> empty .)
    MINUS           reduce using rule 31 (opt_params -> empty .)
    NUM             reduce using rule 31 (opt_params -> empty .)
    COLON           reduce using rule 31 (opt_params -> empty .)
    BOOL            reduce using rule 31 (opt_params -> empty .)
    NOT             reduce using rule 31 (opt_params -> empty .)
    TO              reduce using rule 31 (opt_params -> empty .)
    $end            reduce using rule 31 (opt_params -> empty .)
    END             reduce using rule 31 (opt_params -> empty .)
    ELSE            reduce using rule 31 (opt_params -> empty .)


state 27

    (18) num_expression -> num_expression PLUS . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 49

state 28

    (19) num_expression -> num_expression MINUS . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 50

state 29

    (20) num_expression -> num_expression TIMES . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 51

state 30

    (21) num_expression -> num_expression DIVIDE . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 52

state 31

    (22) num_expression -> num_expression POWER . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 53

state 32

    (14) bool_expression -> num_expression REL_OP . num_expression
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 54

state 33

    (15) bool_expression -> bool_expression AND_OR . bool_expression
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    OPEN_PAR        shift and go to state 43
    COLON           shift and go to state 44
    MINUS           shift and go to state 13
    NUM             shift and go to state 14

    bool_expression                shift and go to state 55
    num_expression                 shift and go to state 42

state 34

    (33) if -> IF OPEN_PAR . bool_expression CLOSE_PAR THEN statement possible_else END
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    OPEN_PAR        shift and go to state 43
    COLON           shift and go to state 44
    MINUS           shift and go to state 13
    NUM             shift and go to state 14

    bool_expression                shift and go to state 56
    num_expression                 shift and go to state 42

state 35

    (23) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression
    (14) bool_expression -> num_expression . REL_OP num_expression

    CLOSE_PAR       shift and go to state 57
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31
    REL_OP          shift and go to state 32


state 36

    (16) bool_expression -> OPEN_PAR bool_expression . CLOSE_PAR
    (15) bool_expression -> bool_expression . AND_OR bool_expression

    CLOSE_PAR       shift and go to state 58
    AND_OR          shift and go to state 33


state 37

    (24) num_expression -> MINUS num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 24 (num_expression -> MINUS num_expression .)
    MINUS           reduce using rule 24 (num_expression -> MINUS num_expression .)
    REL_OP          reduce using rule 24 (num_expression -> MINUS num_expression .)
    IDENTIFIER      reduce using rule 24 (num_expression -> MINUS num_expression .)
    IF              reduce using rule 24 (num_expression -> MINUS num_expression .)
    OPEN_PAR        reduce using rule 24 (num_expression -> MINUS num_expression .)
    NUM             reduce using rule 24 (num_expression -> MINUS num_expression .)
    COLON           reduce using rule 24 (num_expression -> MINUS num_expression .)
    BOOL            reduce using rule 24 (num_expression -> MINUS num_expression .)
    NOT             reduce using rule 24 (num_expression -> MINUS num_expression .)
    TO              reduce using rule 24 (num_expression -> MINUS num_expression .)
    $end            reduce using rule 24 (num_expression -> MINUS num_expression .)
    END             reduce using rule 24 (num_expression -> MINUS num_expression .)
    ELSE            reduce using rule 24 (num_expression -> MINUS num_expression .)
    CLOSE_PAR       reduce using rule 24 (num_expression -> MINUS num_expression .)
    AND_OR          reduce using rule 24 (num_expression -> MINUS num_expression .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31

  ! TIMES           [ reduce using rule 24 (num_expression -> MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 24 (num_expression -> MINUS num_expression .) ]
  ! POWER           [ reduce using rule 24 (num_expression -> MINUS num_expression .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]


state 38

    (23) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 38
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 39

    num_expression                 shift and go to state 59

state 39

    (26) num_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 60


state 40

    (26) num_expression -> COLON IDENTIFIER .
    (17) bool_expression -> COLON IDENTIFIER .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for OPEN_PAR resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for NUM resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for COLON resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for BOOL resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for TO resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for END resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for CLOSE_PAR resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
    PLUS            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    END             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)

  ! MINUS           [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! IF              [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! OPEN_PAR        [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! NUM             [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! COLON           [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! BOOL            [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! NOT             [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! TO              [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! $end            [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! END             [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! CLOSE_PAR       [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]


state 41

    (13) bool_expression -> NOT bool_expression .
    (15) bool_expression -> bool_expression . AND_OR bool_expression

  ! shift/reduce conflict for AND_OR resolved as shift
    IDENTIFIER      reduce using rule 13 (bool_expression -> NOT bool_expression .)
    IF              reduce using rule 13 (bool_expression -> NOT bool_expression .)
    OPEN_PAR        reduce using rule 13 (bool_expression -> NOT bool_expression .)
    MINUS           reduce using rule 13 (bool_expression -> NOT bool_expression .)
    NUM             reduce using rule 13 (bool_expression -> NOT bool_expression .)
    COLON           reduce using rule 13 (bool_expression -> NOT bool_expression .)
    BOOL            reduce using rule 13 (bool_expression -> NOT bool_expression .)
    NOT             reduce using rule 13 (bool_expression -> NOT bool_expression .)
    TO              reduce using rule 13 (bool_expression -> NOT bool_expression .)
    $end            reduce using rule 13 (bool_expression -> NOT bool_expression .)
    END             reduce using rule 13 (bool_expression -> NOT bool_expression .)
    ELSE            reduce using rule 13 (bool_expression -> NOT bool_expression .)
    CLOSE_PAR       reduce using rule 13 (bool_expression -> NOT bool_expression .)
    AND_OR          shift and go to state 33

  ! AND_OR          [ reduce using rule 13 (bool_expression -> NOT bool_expression .) ]


state 42

    (14) bool_expression -> num_expression . REL_OP num_expression
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    REL_OP          shift and go to state 32
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31


state 43

    (16) bool_expression -> OPEN_PAR . bool_expression CLOSE_PAR
    (23) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    OPEN_PAR        shift and go to state 43
    COLON           shift and go to state 44
    MINUS           shift and go to state 13
    NUM             shift and go to state 14

    bool_expression                shift and go to state 36
    num_expression                 shift and go to state 61

state 44

    (17) bool_expression -> COLON . IDENTIFIER
    (26) num_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 62


state 45

    (27) func -> TO IDENTIFIER . OPEN_PAR opt_args CLOSE_PAR program END

    OPEN_PAR        shift and go to state 63


state 46

    (6) other_statement -> statement other_statement .

    $end            reduce using rule 6 (other_statement -> statement other_statement .)
    END             reduce using rule 6 (other_statement -> statement other_statement .)


state 47

    (5) assign -> IDENTIFIER EQUALS expression .

    IDENTIFIER      reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    IF              reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    OPEN_PAR        reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    MINUS           reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    NUM             reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    COLON           reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    BOOL            reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    NOT             reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    TO              reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    $end            reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    END             reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)
    ELSE            reduce using rule 5 (assign -> IDENTIFIER EQUALS expression .)


state 48

    (30) opt_params -> expression opt_params .

    IDENTIFIER      reduce using rule 30 (opt_params -> expression opt_params .)
    IF              reduce using rule 30 (opt_params -> expression opt_params .)
    OPEN_PAR        reduce using rule 30 (opt_params -> expression opt_params .)
    MINUS           reduce using rule 30 (opt_params -> expression opt_params .)
    NUM             reduce using rule 30 (opt_params -> expression opt_params .)
    COLON           reduce using rule 30 (opt_params -> expression opt_params .)
    BOOL            reduce using rule 30 (opt_params -> expression opt_params .)
    NOT             reduce using rule 30 (opt_params -> expression opt_params .)
    TO              reduce using rule 30 (opt_params -> expression opt_params .)
    $end            reduce using rule 30 (opt_params -> expression opt_params .)
    END             reduce using rule 30 (opt_params -> expression opt_params .)
    ELSE            reduce using rule 30 (opt_params -> expression opt_params .)


state 49

    (18) num_expression -> num_expression PLUS num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    MINUS           reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    REL_OP          reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    IDENTIFIER      reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    IF              reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    OPEN_PAR        reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    NUM             reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    COLON           reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    BOOL            reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    NOT             reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    TO              reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    $end            reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    END             reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    ELSE            reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    CLOSE_PAR       reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    AND_OR          reduce using rule 18 (num_expression -> num_expression PLUS num_expression .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31

  ! TIMES           [ reduce using rule 18 (num_expression -> num_expression PLUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 18 (num_expression -> num_expression PLUS num_expression .) ]
  ! POWER           [ reduce using rule 18 (num_expression -> num_expression PLUS num_expression .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]


state 50

    (19) num_expression -> num_expression MINUS num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    MINUS           reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    REL_OP          reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    IDENTIFIER      reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    IF              reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    OPEN_PAR        reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    NUM             reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    COLON           reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    BOOL            reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    NOT             reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    TO              reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    $end            reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    END             reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    ELSE            reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    CLOSE_PAR       reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    AND_OR          reduce using rule 19 (num_expression -> num_expression MINUS num_expression .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31

  ! TIMES           [ reduce using rule 19 (num_expression -> num_expression MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 19 (num_expression -> num_expression MINUS num_expression .) ]
  ! POWER           [ reduce using rule 19 (num_expression -> num_expression MINUS num_expression .) ]
  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]


state 51

    (20) num_expression -> num_expression TIMES num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    MINUS           reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    TIMES           reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    DIVIDE          reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    POWER           reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    REL_OP          reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    IDENTIFIER      reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    IF              reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    OPEN_PAR        reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    NUM             reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    COLON           reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    BOOL            reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    NOT             reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    TO              reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    $end            reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    END             reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    ELSE            reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    CLOSE_PAR       reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)
    AND_OR          reduce using rule 20 (num_expression -> num_expression TIMES num_expression .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! POWER           [ shift and go to state 31 ]


state 52

    (21) num_expression -> num_expression DIVIDE num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    MINUS           reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    TIMES           reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    DIVIDE          reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    POWER           reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    REL_OP          reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    IDENTIFIER      reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    IF              reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    OPEN_PAR        reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    NUM             reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    COLON           reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    BOOL            reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    NOT             reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    TO              reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    $end            reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    END             reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    ELSE            reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    CLOSE_PAR       reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)
    AND_OR          reduce using rule 21 (num_expression -> num_expression DIVIDE num_expression .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! POWER           [ shift and go to state 31 ]


state 53

    (22) num_expression -> num_expression POWER num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    MINUS           reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    TIMES           reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    DIVIDE          reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    POWER           reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    REL_OP          reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    IDENTIFIER      reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    IF              reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    OPEN_PAR        reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    NUM             reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    COLON           reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    BOOL            reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    NOT             reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    TO              reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    $end            reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    END             reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    ELSE            reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    CLOSE_PAR       reduce using rule 22 (num_expression -> num_expression POWER num_expression .)
    AND_OR          reduce using rule 22 (num_expression -> num_expression POWER num_expression .)

  ! PLUS            [ shift and go to state 27 ]
  ! MINUS           [ shift and go to state 28 ]
  ! TIMES           [ shift and go to state 29 ]
  ! DIVIDE          [ shift and go to state 30 ]
  ! POWER           [ shift and go to state 31 ]


state 54

    (14) bool_expression -> num_expression REL_OP num_expression .
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

  ! shift/reduce conflict for MINUS resolved as shift
    AND_OR          reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    IDENTIFIER      reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    IF              reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    OPEN_PAR        reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    NUM             reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    COLON           reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    BOOL            reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    NOT             reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    TO              reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    $end            reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    END             reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    ELSE            reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    CLOSE_PAR       reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .)
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31

  ! MINUS           [ reduce using rule 14 (bool_expression -> num_expression REL_OP num_expression .) ]


state 55

    (15) bool_expression -> bool_expression AND_OR bool_expression .
    (15) bool_expression -> bool_expression . AND_OR bool_expression

  ! shift/reduce conflict for AND_OR resolved as shift
    IDENTIFIER      reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    IF              reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    OPEN_PAR        reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    MINUS           reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    NUM             reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    COLON           reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    BOOL            reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    NOT             reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    TO              reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    $end            reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    END             reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    ELSE            reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    CLOSE_PAR       reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .)
    AND_OR          shift and go to state 33

  ! AND_OR          [ reduce using rule 15 (bool_expression -> bool_expression AND_OR bool_expression .) ]


state 56

    (33) if -> IF OPEN_PAR bool_expression . CLOSE_PAR THEN statement possible_else END
    (15) bool_expression -> bool_expression . AND_OR bool_expression

    CLOSE_PAR       shift and go to state 64
    AND_OR          shift and go to state 33


state 57

    (23) num_expression -> OPEN_PAR num_expression CLOSE_PAR .

    PLUS            reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    MINUS           reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    TIMES           reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    DIVIDE          reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    POWER           reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    REL_OP          reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    IDENTIFIER      reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    IF              reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    OPEN_PAR        reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    NUM             reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    COLON           reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    BOOL            reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    NOT             reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    TO              reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    $end            reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    END             reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    ELSE            reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    CLOSE_PAR       reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    AND_OR          reduce using rule 23 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)


state 58

    (16) bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .

    AND_OR          reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    IDENTIFIER      reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    IF              reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    OPEN_PAR        reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    MINUS           reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    NUM             reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    COLON           reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    BOOL            reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    NOT             reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    TO              reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    $end            reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    END             reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    ELSE            reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    CLOSE_PAR       reduce using rule 16 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)


state 59

    (23) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    CLOSE_PAR       shift and go to state 57
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31


state 60

    (26) num_expression -> COLON IDENTIFIER .

    PLUS            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    END             reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)


state 61

    (23) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (14) bool_expression -> num_expression . REL_OP num_expression
    (18) num_expression -> num_expression . PLUS num_expression
    (19) num_expression -> num_expression . MINUS num_expression
    (20) num_expression -> num_expression . TIMES num_expression
    (21) num_expression -> num_expression . DIVIDE num_expression
    (22) num_expression -> num_expression . POWER num_expression

    CLOSE_PAR       shift and go to state 57
    REL_OP          shift and go to state 32
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30
    POWER           shift and go to state 31


state 62

    (17) bool_expression -> COLON IDENTIFIER .
    (26) num_expression -> COLON IDENTIFIER .

  ! reduce/reduce conflict for MINUS resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for CLOSE_PAR resolved using rule 17 (bool_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    END             reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 17 (bool_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    PLUS            reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 26 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 26 (num_expression -> COLON IDENTIFIER .)

  ! MINUS           [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]
  ! CLOSE_PAR       [ reduce using rule 26 (num_expression -> COLON IDENTIFIER .) ]


state 63

    (27) func -> TO IDENTIFIER OPEN_PAR . opt_args CLOSE_PAR program END
    (28) opt_args -> . IDENTIFIER opt_args
    (29) opt_args -> . empty
    (36) empty -> .

    IDENTIFIER      shift and go to state 65
    CLOSE_PAR       reduce using rule 36 (empty -> .)

    opt_args                       shift and go to state 66
    empty                          shift and go to state 67

state 64

    (33) if -> IF OPEN_PAR bool_expression CLOSE_PAR . THEN statement possible_else END

    THEN            shift and go to state 68


state 65

    (28) opt_args -> IDENTIFIER . opt_args
    (28) opt_args -> . IDENTIFIER opt_args
    (29) opt_args -> . empty
    (36) empty -> .

    IDENTIFIER      shift and go to state 65
    CLOSE_PAR       reduce using rule 36 (empty -> .)

    opt_args                       shift and go to state 69
    empty                          shift and go to state 67

state 66

    (27) func -> TO IDENTIFIER OPEN_PAR opt_args . CLOSE_PAR program END

    CLOSE_PAR       shift and go to state 70


state 67

    (29) opt_args -> empty .

    CLOSE_PAR       reduce using rule 29 (opt_args -> empty .)


state 68

    (33) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN . statement possible_else END
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    bool_expression                shift and go to state 8
    statement                      shift and go to state 71
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 69

    (28) opt_args -> IDENTIFIER opt_args .

    CLOSE_PAR       reduce using rule 28 (opt_args -> IDENTIFIER opt_args .)


state 70

    (27) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR . program END
    (1) program -> . statement other_statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    program                        shift and go to state 72
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 71

    (33) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement . possible_else END
    (34) possible_else -> . ELSE statement END
    (35) possible_else -> . empty
    (36) empty -> .

    ELSE            shift and go to state 74
    END             reduce using rule 36 (empty -> .)

    possible_else                  shift and go to state 73
    empty                          shift and go to state 75

state 72

    (27) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program . END

    END             shift and go to state 76


state 73

    (33) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else . END

    END             shift and go to state 77


state 74

    (34) possible_else -> ELSE . statement END
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) assign -> . IDENTIFIER EQUALS expression
    (8) expression -> . num_expression
    (9) expression -> . bool_expression
    (10) expression -> . func
    (11) expression -> . call_func
    (33) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (18) num_expression -> . num_expression PLUS num_expression
    (19) num_expression -> . num_expression MINUS num_expression
    (20) num_expression -> . num_expression TIMES num_expression
    (21) num_expression -> . num_expression DIVIDE num_expression
    (22) num_expression -> . num_expression POWER num_expression
    (23) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (24) num_expression -> . MINUS num_expression
    (25) num_expression -> . NUM
    (26) num_expression -> . COLON IDENTIFIER
    (12) bool_expression -> . BOOL
    (13) bool_expression -> . NOT bool_expression
    (14) bool_expression -> . num_expression REL_OP num_expression
    (15) bool_expression -> . bool_expression AND_OR bool_expression
    (16) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (17) bool_expression -> . COLON IDENTIFIER
    (27) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (32) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 6
    IF              shift and go to state 11
    OPEN_PAR        shift and go to state 12
    MINUS           shift and go to state 13
    NUM             shift and go to state 14
    COLON           shift and go to state 15
    BOOL            shift and go to state 16
    NOT             shift and go to state 17
    TO              shift and go to state 18

    statement                      shift and go to state 78
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    num_expression                 shift and go to state 7
    bool_expression                shift and go to state 8
    func                           shift and go to state 9
    call_func                      shift and go to state 10

state 75

    (35) possible_else -> empty .

    END             reduce using rule 35 (possible_else -> empty .)


state 76

    (27) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .

    IDENTIFIER      reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    IF              reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    OPEN_PAR        reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    MINUS           reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    NUM             reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    COLON           reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    BOOL            reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    NOT             reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    TO              reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    $end            reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    END             reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    ELSE            reduce using rule 27 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)


state 77

    (33) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .

    IDENTIFIER      reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    IF              reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    OPEN_PAR        reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    MINUS           reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    NUM             reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    COLON           reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    BOOL            reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    NOT             reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    TO              reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    $end            reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    END             reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    ELSE            reduce using rule 33 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)


state 78

    (34) possible_else -> ELSE statement . END

    END             shift and go to state 79


state 79

    (34) possible_else -> ELSE statement END .

    END             reduce using rule 34 (possible_else -> ELSE statement END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OPEN_PAR in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 6 resolved as shift
WARNING: shift/reduce conflict for NUM in state 6 resolved as shift
WARNING: shift/reduce conflict for COLON in state 6 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 6 resolved as shift
WARNING: shift/reduce conflict for NOT in state 6 resolved as shift
WARNING: shift/reduce conflict for TO in state 6 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 6 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAR in state 22 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 22 resolved as shift
WARNING: shift/reduce conflict for NUM in state 22 resolved as shift
WARNING: shift/reduce conflict for COLON in state 22 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 22 resolved as shift
WARNING: shift/reduce conflict for NOT in state 22 resolved as shift
WARNING: shift/reduce conflict for TO in state 22 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 22 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAR in state 24 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 24 resolved as shift
WARNING: shift/reduce conflict for NUM in state 24 resolved as shift
WARNING: shift/reduce conflict for COLON in state 24 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 24 resolved as shift
WARNING: shift/reduce conflict for NOT in state 24 resolved as shift
WARNING: shift/reduce conflict for TO in state 24 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 24 resolved as shift
WARNING: shift/reduce conflict for AND_OR in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 54 resolved as shift
WARNING: shift/reduce conflict for AND_OR in state 55 resolved as shift
WARNING: reduce/reduce conflict in state 40 resolved using rule (bool_expression -> COLON IDENTIFIER)
WARNING: rejected rule (num_expression -> COLON IDENTIFIER) in state 40
WARNING: reduce/reduce conflict in state 62 resolved using rule (bool_expression -> COLON IDENTIFIER)
WARNING: rejected rule (num_expression -> COLON IDENTIFIER) in state 62
