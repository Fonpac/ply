Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> statement other_statement
Rule 2     statement -> assign
Rule 3     statement -> expression
Rule 4     statement -> if
Rule 5     statement -> while
Rule 6     while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END
Rule 7     assign -> IDENTIFIER EQUALS expression
Rule 8     other_statement -> statement other_statement
Rule 9     other_statement -> empty
Rule 10    expression -> num_expression
Rule 11    expression -> bool_expression
Rule 12    expression -> func
Rule 13    expression -> call_func
Rule 14    bool_expression -> BOOL
Rule 15    bool_expression -> NOT bool_expression
Rule 16    bool_expression -> num_expression REL_OP num_expression
Rule 17    bool_expression -> bool_expression AND_OR bool_expression
Rule 18    bool_expression -> OPEN_PAR bool_expression CLOSE_PAR
Rule 19    bool_expression -> COLON IDENTIFIER
Rule 20    num_expression -> num_expression PLUS num_expression
Rule 21    num_expression -> num_expression MINUS num_expression
Rule 22    num_expression -> num_expression TIMES num_expression
Rule 23    num_expression -> num_expression DIVIDE num_expression
Rule 24    num_expression -> num_expression POWER num_expression
Rule 25    num_expression -> OPEN_PAR num_expression CLOSE_PAR
Rule 26    num_expression -> MINUS num_expression
Rule 27    num_expression -> NUM
Rule 28    num_expression -> COLON IDENTIFIER
Rule 29    func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
Rule 30    opt_args -> IDENTIFIER opt_args
Rule 31    opt_args -> empty
Rule 32    opt_params -> expression opt_params
Rule 33    opt_params -> empty
Rule 34    call_func -> IDENTIFIER opt_params
Rule 35    if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
Rule 36    possible_else -> ELSE statement
Rule 37    possible_else -> empty
Rule 38    empty -> <empty>

Terminals, with rules where they appear

AND_OR               : 17
BOOL                 : 14
CLOSE_PAR            : 6 18 25 29 35
COLON                : 19 28
DIVIDE               : 23
ELSE                 : 36
END                  : 6 29 35
EQUALS               : 7
IDENTIFIER           : 7 19 28 29 30 34
IF                   : 35
MINUS                : 21 26
NOT                  : 15
NUM                  : 27
OPEN_PAR             : 6 18 25 29 35
PLUS                 : 20
POWER                : 24
REL_OP               : 16
THEN                 : 35
TIMES                : 22
TO                   : 29
WHILE                : 6
error                : 

Nonterminals, with rules where they appear

assign               : 2
bool_expression      : 6 11 15 17 17 18 35
call_func            : 13
empty                : 9 31 33 37
expression           : 3 7 32
func                 : 12
if                   : 4
num_expression       : 10 16 16 20 20 21 21 22 22 23 23 24 24 25 26
opt_args             : 29 30
opt_params           : 32 34
other_statement      : 1 8
possible_else        : 35
program              : 6 29 0
statement            : 1 8 35 36
while                : 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement other_statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    program                        shift and go to state 1
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 1

    (0) S' -> program .



state 2

    (1) program -> statement . other_statement
    (8) other_statement -> . statement other_statement
    (9) other_statement -> . empty
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (38) empty -> .
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    $end            reduce using rule 38 (empty -> .)
    END             reduce using rule 38 (empty -> .)
    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    statement                      shift and go to state 21
    other_statement                shift and go to state 22
    empty                          shift and go to state 23
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 3

    (2) statement -> assign .

    IDENTIFIER      reduce using rule 2 (statement -> assign .)
    IF              reduce using rule 2 (statement -> assign .)
    WHILE           reduce using rule 2 (statement -> assign .)
    OPEN_PAR        reduce using rule 2 (statement -> assign .)
    MINUS           reduce using rule 2 (statement -> assign .)
    NUM             reduce using rule 2 (statement -> assign .)
    COLON           reduce using rule 2 (statement -> assign .)
    BOOL            reduce using rule 2 (statement -> assign .)
    NOT             reduce using rule 2 (statement -> assign .)
    TO              reduce using rule 2 (statement -> assign .)
    $end            reduce using rule 2 (statement -> assign .)
    END             reduce using rule 2 (statement -> assign .)
    ELSE            reduce using rule 2 (statement -> assign .)


state 4

    (3) statement -> expression .

    IDENTIFIER      reduce using rule 3 (statement -> expression .)
    IF              reduce using rule 3 (statement -> expression .)
    WHILE           reduce using rule 3 (statement -> expression .)
    OPEN_PAR        reduce using rule 3 (statement -> expression .)
    MINUS           reduce using rule 3 (statement -> expression .)
    NUM             reduce using rule 3 (statement -> expression .)
    COLON           reduce using rule 3 (statement -> expression .)
    BOOL            reduce using rule 3 (statement -> expression .)
    NOT             reduce using rule 3 (statement -> expression .)
    TO              reduce using rule 3 (statement -> expression .)
    $end            reduce using rule 3 (statement -> expression .)
    END             reduce using rule 3 (statement -> expression .)
    ELSE            reduce using rule 3 (statement -> expression .)


state 5

    (4) statement -> if .

    IDENTIFIER      reduce using rule 4 (statement -> if .)
    IF              reduce using rule 4 (statement -> if .)
    WHILE           reduce using rule 4 (statement -> if .)
    OPEN_PAR        reduce using rule 4 (statement -> if .)
    MINUS           reduce using rule 4 (statement -> if .)
    NUM             reduce using rule 4 (statement -> if .)
    COLON           reduce using rule 4 (statement -> if .)
    BOOL            reduce using rule 4 (statement -> if .)
    NOT             reduce using rule 4 (statement -> if .)
    TO              reduce using rule 4 (statement -> if .)
    $end            reduce using rule 4 (statement -> if .)
    END             reduce using rule 4 (statement -> if .)
    ELSE            reduce using rule 4 (statement -> if .)


state 6

    (5) statement -> while .

    IDENTIFIER      reduce using rule 5 (statement -> while .)
    IF              reduce using rule 5 (statement -> while .)
    WHILE           reduce using rule 5 (statement -> while .)
    OPEN_PAR        reduce using rule 5 (statement -> while .)
    MINUS           reduce using rule 5 (statement -> while .)
    NUM             reduce using rule 5 (statement -> while .)
    COLON           reduce using rule 5 (statement -> while .)
    BOOL            reduce using rule 5 (statement -> while .)
    NOT             reduce using rule 5 (statement -> while .)
    TO              reduce using rule 5 (statement -> while .)
    $end            reduce using rule 5 (statement -> while .)
    END             reduce using rule 5 (statement -> while .)
    ELSE            reduce using rule 5 (statement -> while .)


state 7

    (7) assign -> IDENTIFIER . EQUALS expression
    (34) call_func -> IDENTIFIER . opt_params
    (32) opt_params -> . expression opt_params
    (33) opt_params -> . empty
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (38) empty -> .
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    EQUALS          shift and go to state 25
    IF              reduce using rule 38 (empty -> .)
    WHILE           reduce using rule 38 (empty -> .)
    $end            reduce using rule 38 (empty -> .)
    END             reduce using rule 38 (empty -> .)
    ELSE            reduce using rule 38 (empty -> .)
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20
    IDENTIFIER      shift and go to state 24

  ! IDENTIFIER      [ reduce using rule 38 (empty -> .) ]
  ! OPEN_PAR        [ reduce using rule 38 (empty -> .) ]
  ! MINUS           [ reduce using rule 38 (empty -> .) ]
  ! NUM             [ reduce using rule 38 (empty -> .) ]
  ! COLON           [ reduce using rule 38 (empty -> .) ]
  ! BOOL            [ reduce using rule 38 (empty -> .) ]
  ! NOT             [ reduce using rule 38 (empty -> .) ]
  ! TO              [ reduce using rule 38 (empty -> .) ]

    expression                     shift and go to state 26
    opt_params                     shift and go to state 27
    empty                          shift and go to state 28
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 8

    (10) expression -> num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression
    (16) bool_expression -> num_expression . REL_OP num_expression

  ! shift/reduce conflict for MINUS resolved as shift
    IDENTIFIER      reduce using rule 10 (expression -> num_expression .)
    IF              reduce using rule 10 (expression -> num_expression .)
    WHILE           reduce using rule 10 (expression -> num_expression .)
    OPEN_PAR        reduce using rule 10 (expression -> num_expression .)
    NUM             reduce using rule 10 (expression -> num_expression .)
    COLON           reduce using rule 10 (expression -> num_expression .)
    BOOL            reduce using rule 10 (expression -> num_expression .)
    NOT             reduce using rule 10 (expression -> num_expression .)
    TO              reduce using rule 10 (expression -> num_expression .)
    $end            reduce using rule 10 (expression -> num_expression .)
    END             reduce using rule 10 (expression -> num_expression .)
    ELSE            reduce using rule 10 (expression -> num_expression .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    REL_OP          shift and go to state 34

  ! MINUS           [ reduce using rule 10 (expression -> num_expression .) ]


state 9

    (11) expression -> bool_expression .
    (17) bool_expression -> bool_expression . AND_OR bool_expression

    IDENTIFIER      reduce using rule 11 (expression -> bool_expression .)
    IF              reduce using rule 11 (expression -> bool_expression .)
    WHILE           reduce using rule 11 (expression -> bool_expression .)
    OPEN_PAR        reduce using rule 11 (expression -> bool_expression .)
    MINUS           reduce using rule 11 (expression -> bool_expression .)
    NUM             reduce using rule 11 (expression -> bool_expression .)
    COLON           reduce using rule 11 (expression -> bool_expression .)
    BOOL            reduce using rule 11 (expression -> bool_expression .)
    NOT             reduce using rule 11 (expression -> bool_expression .)
    TO              reduce using rule 11 (expression -> bool_expression .)
    $end            reduce using rule 11 (expression -> bool_expression .)
    END             reduce using rule 11 (expression -> bool_expression .)
    ELSE            reduce using rule 11 (expression -> bool_expression .)
    AND_OR          shift and go to state 35


state 10

    (12) expression -> func .

    IDENTIFIER      reduce using rule 12 (expression -> func .)
    IF              reduce using rule 12 (expression -> func .)
    WHILE           reduce using rule 12 (expression -> func .)
    OPEN_PAR        reduce using rule 12 (expression -> func .)
    MINUS           reduce using rule 12 (expression -> func .)
    NUM             reduce using rule 12 (expression -> func .)
    COLON           reduce using rule 12 (expression -> func .)
    BOOL            reduce using rule 12 (expression -> func .)
    NOT             reduce using rule 12 (expression -> func .)
    TO              reduce using rule 12 (expression -> func .)
    $end            reduce using rule 12 (expression -> func .)
    END             reduce using rule 12 (expression -> func .)
    ELSE            reduce using rule 12 (expression -> func .)


state 11

    (13) expression -> call_func .

    IDENTIFIER      reduce using rule 13 (expression -> call_func .)
    IF              reduce using rule 13 (expression -> call_func .)
    WHILE           reduce using rule 13 (expression -> call_func .)
    OPEN_PAR        reduce using rule 13 (expression -> call_func .)
    MINUS           reduce using rule 13 (expression -> call_func .)
    NUM             reduce using rule 13 (expression -> call_func .)
    COLON           reduce using rule 13 (expression -> call_func .)
    BOOL            reduce using rule 13 (expression -> call_func .)
    NOT             reduce using rule 13 (expression -> call_func .)
    TO              reduce using rule 13 (expression -> call_func .)
    $end            reduce using rule 13 (expression -> call_func .)
    END             reduce using rule 13 (expression -> call_func .)
    ELSE            reduce using rule 13 (expression -> call_func .)


state 12

    (35) if -> IF . OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END

    OPEN_PAR        shift and go to state 36


state 13

    (25) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (18) bool_expression -> OPEN_PAR . bool_expression CLOSE_PAR
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19

    num_expression                 shift and go to state 37
    bool_expression                shift and go to state 38

state 14

    (6) while -> WHILE . OPEN_PAR bool_expression CLOSE_PAR program END

    OPEN_PAR        shift and go to state 39


state 15

    (26) num_expression -> MINUS . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 40

state 16

    (27) num_expression -> NUM .

    PLUS            reduce using rule 27 (num_expression -> NUM .)
    MINUS           reduce using rule 27 (num_expression -> NUM .)
    TIMES           reduce using rule 27 (num_expression -> NUM .)
    DIVIDE          reduce using rule 27 (num_expression -> NUM .)
    POWER           reduce using rule 27 (num_expression -> NUM .)
    REL_OP          reduce using rule 27 (num_expression -> NUM .)
    IDENTIFIER      reduce using rule 27 (num_expression -> NUM .)
    IF              reduce using rule 27 (num_expression -> NUM .)
    WHILE           reduce using rule 27 (num_expression -> NUM .)
    OPEN_PAR        reduce using rule 27 (num_expression -> NUM .)
    NUM             reduce using rule 27 (num_expression -> NUM .)
    COLON           reduce using rule 27 (num_expression -> NUM .)
    BOOL            reduce using rule 27 (num_expression -> NUM .)
    NOT             reduce using rule 27 (num_expression -> NUM .)
    TO              reduce using rule 27 (num_expression -> NUM .)
    $end            reduce using rule 27 (num_expression -> NUM .)
    END             reduce using rule 27 (num_expression -> NUM .)
    ELSE            reduce using rule 27 (num_expression -> NUM .)
    CLOSE_PAR       reduce using rule 27 (num_expression -> NUM .)
    AND_OR          reduce using rule 27 (num_expression -> NUM .)


state 17

    (28) num_expression -> COLON . IDENTIFIER
    (19) bool_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 43


state 18

    (14) bool_expression -> BOOL .

    AND_OR          reduce using rule 14 (bool_expression -> BOOL .)
    IDENTIFIER      reduce using rule 14 (bool_expression -> BOOL .)
    IF              reduce using rule 14 (bool_expression -> BOOL .)
    WHILE           reduce using rule 14 (bool_expression -> BOOL .)
    OPEN_PAR        reduce using rule 14 (bool_expression -> BOOL .)
    MINUS           reduce using rule 14 (bool_expression -> BOOL .)
    NUM             reduce using rule 14 (bool_expression -> BOOL .)
    COLON           reduce using rule 14 (bool_expression -> BOOL .)
    BOOL            reduce using rule 14 (bool_expression -> BOOL .)
    NOT             reduce using rule 14 (bool_expression -> BOOL .)
    TO              reduce using rule 14 (bool_expression -> BOOL .)
    $end            reduce using rule 14 (bool_expression -> BOOL .)
    END             reduce using rule 14 (bool_expression -> BOOL .)
    ELSE            reduce using rule 14 (bool_expression -> BOOL .)
    CLOSE_PAR       reduce using rule 14 (bool_expression -> BOOL .)


state 19

    (15) bool_expression -> NOT . bool_expression
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    OPEN_PAR        shift and go to state 46
    COLON           shift and go to state 47
    MINUS           shift and go to state 15
    NUM             shift and go to state 16

    bool_expression                shift and go to state 44
    num_expression                 shift and go to state 45

state 20

    (29) func -> TO . IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END

    IDENTIFIER      shift and go to state 48


state 21

    (8) other_statement -> statement . other_statement
    (8) other_statement -> . statement other_statement
    (9) other_statement -> . empty
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (38) empty -> .
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    $end            reduce using rule 38 (empty -> .)
    END             reduce using rule 38 (empty -> .)
    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    statement                      shift and go to state 21
    other_statement                shift and go to state 49
    empty                          shift and go to state 23
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 22

    (1) program -> statement other_statement .

    $end            reduce using rule 1 (program -> statement other_statement .)
    END             reduce using rule 1 (program -> statement other_statement .)


state 23

    (9) other_statement -> empty .

    $end            reduce using rule 9 (other_statement -> empty .)
    END             reduce using rule 9 (other_statement -> empty .)


state 24

    (34) call_func -> IDENTIFIER . opt_params
    (32) opt_params -> . expression opt_params
    (33) opt_params -> . empty
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (38) empty -> .
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IF              reduce using rule 38 (empty -> .)
    WHILE           reduce using rule 38 (empty -> .)
    $end            reduce using rule 38 (empty -> .)
    END             reduce using rule 38 (empty -> .)
    ELSE            reduce using rule 38 (empty -> .)
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20
    IDENTIFIER      shift and go to state 24

  ! OPEN_PAR        [ reduce using rule 38 (empty -> .) ]
  ! MINUS           [ reduce using rule 38 (empty -> .) ]
  ! NUM             [ reduce using rule 38 (empty -> .) ]
  ! COLON           [ reduce using rule 38 (empty -> .) ]
  ! BOOL            [ reduce using rule 38 (empty -> .) ]
  ! NOT             [ reduce using rule 38 (empty -> .) ]
  ! TO              [ reduce using rule 38 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 38 (empty -> .) ]

    opt_params                     shift and go to state 27
    expression                     shift and go to state 26
    empty                          shift and go to state 28
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 25

    (7) assign -> IDENTIFIER EQUALS . expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20
    IDENTIFIER      shift and go to state 24

    expression                     shift and go to state 50
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 26

    (32) opt_params -> expression . opt_params
    (32) opt_params -> . expression opt_params
    (33) opt_params -> . empty
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (38) empty -> .
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

  ! shift/reduce conflict for OPEN_PAR resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for COLON resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for TO resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IF              reduce using rule 38 (empty -> .)
    WHILE           reduce using rule 38 (empty -> .)
    $end            reduce using rule 38 (empty -> .)
    END             reduce using rule 38 (empty -> .)
    ELSE            reduce using rule 38 (empty -> .)
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20
    IDENTIFIER      shift and go to state 24

  ! OPEN_PAR        [ reduce using rule 38 (empty -> .) ]
  ! MINUS           [ reduce using rule 38 (empty -> .) ]
  ! NUM             [ reduce using rule 38 (empty -> .) ]
  ! COLON           [ reduce using rule 38 (empty -> .) ]
  ! BOOL            [ reduce using rule 38 (empty -> .) ]
  ! NOT             [ reduce using rule 38 (empty -> .) ]
  ! TO              [ reduce using rule 38 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 38 (empty -> .) ]

    expression                     shift and go to state 26
    opt_params                     shift and go to state 51
    empty                          shift and go to state 28
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 27

    (34) call_func -> IDENTIFIER opt_params .

    IDENTIFIER      reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    IF              reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    WHILE           reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    OPEN_PAR        reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    MINUS           reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    NUM             reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    COLON           reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    BOOL            reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    NOT             reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    TO              reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    $end            reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    END             reduce using rule 34 (call_func -> IDENTIFIER opt_params .)
    ELSE            reduce using rule 34 (call_func -> IDENTIFIER opt_params .)


state 28

    (33) opt_params -> empty .

    IDENTIFIER      reduce using rule 33 (opt_params -> empty .)
    IF              reduce using rule 33 (opt_params -> empty .)
    WHILE           reduce using rule 33 (opt_params -> empty .)
    OPEN_PAR        reduce using rule 33 (opt_params -> empty .)
    MINUS           reduce using rule 33 (opt_params -> empty .)
    NUM             reduce using rule 33 (opt_params -> empty .)
    COLON           reduce using rule 33 (opt_params -> empty .)
    BOOL            reduce using rule 33 (opt_params -> empty .)
    NOT             reduce using rule 33 (opt_params -> empty .)
    TO              reduce using rule 33 (opt_params -> empty .)
    $end            reduce using rule 33 (opt_params -> empty .)
    END             reduce using rule 33 (opt_params -> empty .)
    ELSE            reduce using rule 33 (opt_params -> empty .)


state 29

    (20) num_expression -> num_expression PLUS . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 52

state 30

    (21) num_expression -> num_expression MINUS . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 53

state 31

    (22) num_expression -> num_expression TIMES . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 54

state 32

    (23) num_expression -> num_expression DIVIDE . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 55

state 33

    (24) num_expression -> num_expression POWER . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 56

state 34

    (16) bool_expression -> num_expression REL_OP . num_expression
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 57

state 35

    (17) bool_expression -> bool_expression AND_OR . bool_expression
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    OPEN_PAR        shift and go to state 46
    COLON           shift and go to state 47
    MINUS           shift and go to state 15
    NUM             shift and go to state 16

    bool_expression                shift and go to state 58
    num_expression                 shift and go to state 45

state 36

    (35) if -> IF OPEN_PAR . bool_expression CLOSE_PAR THEN statement possible_else END
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    OPEN_PAR        shift and go to state 46
    COLON           shift and go to state 47
    MINUS           shift and go to state 15
    NUM             shift and go to state 16

    bool_expression                shift and go to state 59
    num_expression                 shift and go to state 45

state 37

    (25) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression
    (16) bool_expression -> num_expression . REL_OP num_expression

    CLOSE_PAR       shift and go to state 60
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33
    REL_OP          shift and go to state 34


state 38

    (18) bool_expression -> OPEN_PAR bool_expression . CLOSE_PAR
    (17) bool_expression -> bool_expression . AND_OR bool_expression

    CLOSE_PAR       shift and go to state 61
    AND_OR          shift and go to state 35


state 39

    (6) while -> WHILE OPEN_PAR . bool_expression CLOSE_PAR program END
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    OPEN_PAR        shift and go to state 46
    COLON           shift and go to state 47
    MINUS           shift and go to state 15
    NUM             shift and go to state 16

    bool_expression                shift and go to state 62
    num_expression                 shift and go to state 45

state 40

    (26) num_expression -> MINUS num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 26 (num_expression -> MINUS num_expression .)
    MINUS           reduce using rule 26 (num_expression -> MINUS num_expression .)
    REL_OP          reduce using rule 26 (num_expression -> MINUS num_expression .)
    IDENTIFIER      reduce using rule 26 (num_expression -> MINUS num_expression .)
    IF              reduce using rule 26 (num_expression -> MINUS num_expression .)
    WHILE           reduce using rule 26 (num_expression -> MINUS num_expression .)
    OPEN_PAR        reduce using rule 26 (num_expression -> MINUS num_expression .)
    NUM             reduce using rule 26 (num_expression -> MINUS num_expression .)
    COLON           reduce using rule 26 (num_expression -> MINUS num_expression .)
    BOOL            reduce using rule 26 (num_expression -> MINUS num_expression .)
    NOT             reduce using rule 26 (num_expression -> MINUS num_expression .)
    TO              reduce using rule 26 (num_expression -> MINUS num_expression .)
    $end            reduce using rule 26 (num_expression -> MINUS num_expression .)
    END             reduce using rule 26 (num_expression -> MINUS num_expression .)
    ELSE            reduce using rule 26 (num_expression -> MINUS num_expression .)
    CLOSE_PAR       reduce using rule 26 (num_expression -> MINUS num_expression .)
    AND_OR          reduce using rule 26 (num_expression -> MINUS num_expression .)
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33

  ! TIMES           [ reduce using rule 26 (num_expression -> MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 26 (num_expression -> MINUS num_expression .) ]
  ! POWER           [ reduce using rule 26 (num_expression -> MINUS num_expression .) ]
  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]


state 41

    (25) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    OPEN_PAR        shift and go to state 41
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 42

    num_expression                 shift and go to state 63

state 42

    (28) num_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 64


state 43

    (28) num_expression -> COLON IDENTIFIER .
    (19) bool_expression -> COLON IDENTIFIER .

  ! reduce/reduce conflict for IDENTIFIER resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for OPEN_PAR resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for NUM resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for COLON resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for BOOL resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for TO resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for END resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for CLOSE_PAR resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
    PLUS            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    WHILE           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    END             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)

  ! MINUS           [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! IF              [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! OPEN_PAR        [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! NUM             [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! COLON           [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! BOOL            [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! NOT             [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! TO              [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! $end            [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! END             [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! CLOSE_PAR       [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]


state 44

    (15) bool_expression -> NOT bool_expression .
    (17) bool_expression -> bool_expression . AND_OR bool_expression

  ! shift/reduce conflict for AND_OR resolved as shift
    IDENTIFIER      reduce using rule 15 (bool_expression -> NOT bool_expression .)
    IF              reduce using rule 15 (bool_expression -> NOT bool_expression .)
    WHILE           reduce using rule 15 (bool_expression -> NOT bool_expression .)
    OPEN_PAR        reduce using rule 15 (bool_expression -> NOT bool_expression .)
    MINUS           reduce using rule 15 (bool_expression -> NOT bool_expression .)
    NUM             reduce using rule 15 (bool_expression -> NOT bool_expression .)
    COLON           reduce using rule 15 (bool_expression -> NOT bool_expression .)
    BOOL            reduce using rule 15 (bool_expression -> NOT bool_expression .)
    NOT             reduce using rule 15 (bool_expression -> NOT bool_expression .)
    TO              reduce using rule 15 (bool_expression -> NOT bool_expression .)
    $end            reduce using rule 15 (bool_expression -> NOT bool_expression .)
    END             reduce using rule 15 (bool_expression -> NOT bool_expression .)
    ELSE            reduce using rule 15 (bool_expression -> NOT bool_expression .)
    CLOSE_PAR       reduce using rule 15 (bool_expression -> NOT bool_expression .)
    AND_OR          shift and go to state 35

  ! AND_OR          [ reduce using rule 15 (bool_expression -> NOT bool_expression .) ]


state 45

    (16) bool_expression -> num_expression . REL_OP num_expression
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    REL_OP          shift and go to state 34
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33


state 46

    (18) bool_expression -> OPEN_PAR . bool_expression CLOSE_PAR
    (25) num_expression -> OPEN_PAR . num_expression CLOSE_PAR
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER

    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    OPEN_PAR        shift and go to state 46
    COLON           shift and go to state 47
    MINUS           shift and go to state 15
    NUM             shift and go to state 16

    bool_expression                shift and go to state 38
    num_expression                 shift and go to state 65

state 47

    (19) bool_expression -> COLON . IDENTIFIER
    (28) num_expression -> COLON . IDENTIFIER

    IDENTIFIER      shift and go to state 66


state 48

    (29) func -> TO IDENTIFIER . OPEN_PAR opt_args CLOSE_PAR program END

    OPEN_PAR        shift and go to state 67


state 49

    (8) other_statement -> statement other_statement .

    $end            reduce using rule 8 (other_statement -> statement other_statement .)
    END             reduce using rule 8 (other_statement -> statement other_statement .)


state 50

    (7) assign -> IDENTIFIER EQUALS expression .

    IDENTIFIER      reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    IF              reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    WHILE           reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    OPEN_PAR        reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    MINUS           reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    NUM             reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    COLON           reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    BOOL            reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    NOT             reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    TO              reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    $end            reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    END             reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)
    ELSE            reduce using rule 7 (assign -> IDENTIFIER EQUALS expression .)


state 51

    (32) opt_params -> expression opt_params .

    IDENTIFIER      reduce using rule 32 (opt_params -> expression opt_params .)
    IF              reduce using rule 32 (opt_params -> expression opt_params .)
    WHILE           reduce using rule 32 (opt_params -> expression opt_params .)
    OPEN_PAR        reduce using rule 32 (opt_params -> expression opt_params .)
    MINUS           reduce using rule 32 (opt_params -> expression opt_params .)
    NUM             reduce using rule 32 (opt_params -> expression opt_params .)
    COLON           reduce using rule 32 (opt_params -> expression opt_params .)
    BOOL            reduce using rule 32 (opt_params -> expression opt_params .)
    NOT             reduce using rule 32 (opt_params -> expression opt_params .)
    TO              reduce using rule 32 (opt_params -> expression opt_params .)
    $end            reduce using rule 32 (opt_params -> expression opt_params .)
    END             reduce using rule 32 (opt_params -> expression opt_params .)
    ELSE            reduce using rule 32 (opt_params -> expression opt_params .)


state 52

    (20) num_expression -> num_expression PLUS num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    MINUS           reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    REL_OP          reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    IDENTIFIER      reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    IF              reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    WHILE           reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    OPEN_PAR        reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    NUM             reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    COLON           reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    BOOL            reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    NOT             reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    TO              reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    $end            reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    END             reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    ELSE            reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    CLOSE_PAR       reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    AND_OR          reduce using rule 20 (num_expression -> num_expression PLUS num_expression .)
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33

  ! TIMES           [ reduce using rule 20 (num_expression -> num_expression PLUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 20 (num_expression -> num_expression PLUS num_expression .) ]
  ! POWER           [ reduce using rule 20 (num_expression -> num_expression PLUS num_expression .) ]
  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]


state 53

    (21) num_expression -> num_expression MINUS num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    MINUS           reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    REL_OP          reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    IDENTIFIER      reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    IF              reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    WHILE           reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    OPEN_PAR        reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    NUM             reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    COLON           reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    BOOL            reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    NOT             reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    TO              reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    $end            reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    END             reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    ELSE            reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    CLOSE_PAR       reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    AND_OR          reduce using rule 21 (num_expression -> num_expression MINUS num_expression .)
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33

  ! TIMES           [ reduce using rule 21 (num_expression -> num_expression MINUS num_expression .) ]
  ! DIVIDE          [ reduce using rule 21 (num_expression -> num_expression MINUS num_expression .) ]
  ! POWER           [ reduce using rule 21 (num_expression -> num_expression MINUS num_expression .) ]
  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]


state 54

    (22) num_expression -> num_expression TIMES num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    MINUS           reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    TIMES           reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    DIVIDE          reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    POWER           reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    REL_OP          reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    IDENTIFIER      reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    IF              reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    WHILE           reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    OPEN_PAR        reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    NUM             reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    COLON           reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    BOOL            reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    NOT             reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    TO              reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    $end            reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    END             reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    ELSE            reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    CLOSE_PAR       reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)
    AND_OR          reduce using rule 22 (num_expression -> num_expression TIMES num_expression .)

  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]
  ! TIMES           [ shift and go to state 31 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 33 ]


state 55

    (23) num_expression -> num_expression DIVIDE num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    MINUS           reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    TIMES           reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    DIVIDE          reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    POWER           reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    REL_OP          reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    IDENTIFIER      reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    IF              reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    WHILE           reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    OPEN_PAR        reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    NUM             reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    COLON           reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    BOOL            reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    NOT             reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    TO              reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    $end            reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    END             reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    ELSE            reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    CLOSE_PAR       reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)
    AND_OR          reduce using rule 23 (num_expression -> num_expression DIVIDE num_expression .)

  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]
  ! TIMES           [ shift and go to state 31 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 33 ]


state 56

    (24) num_expression -> num_expression POWER num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    PLUS            reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    MINUS           reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    TIMES           reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    DIVIDE          reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    POWER           reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    REL_OP          reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    IDENTIFIER      reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    IF              reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    WHILE           reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    OPEN_PAR        reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    NUM             reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    COLON           reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    BOOL            reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    NOT             reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    TO              reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    $end            reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    END             reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    ELSE            reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    CLOSE_PAR       reduce using rule 24 (num_expression -> num_expression POWER num_expression .)
    AND_OR          reduce using rule 24 (num_expression -> num_expression POWER num_expression .)

  ! PLUS            [ shift and go to state 29 ]
  ! MINUS           [ shift and go to state 30 ]
  ! TIMES           [ shift and go to state 31 ]
  ! DIVIDE          [ shift and go to state 32 ]
  ! POWER           [ shift and go to state 33 ]


state 57

    (16) bool_expression -> num_expression REL_OP num_expression .
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

  ! shift/reduce conflict for MINUS resolved as shift
    AND_OR          reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    IDENTIFIER      reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    IF              reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    WHILE           reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    OPEN_PAR        reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    NUM             reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    COLON           reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    BOOL            reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    NOT             reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    TO              reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    $end            reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    END             reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    ELSE            reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    CLOSE_PAR       reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .)
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33

  ! MINUS           [ reduce using rule 16 (bool_expression -> num_expression REL_OP num_expression .) ]


state 58

    (17) bool_expression -> bool_expression AND_OR bool_expression .
    (17) bool_expression -> bool_expression . AND_OR bool_expression

  ! shift/reduce conflict for AND_OR resolved as shift
    IDENTIFIER      reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    IF              reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    WHILE           reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    OPEN_PAR        reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    MINUS           reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    NUM             reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    COLON           reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    BOOL            reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    NOT             reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    TO              reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    $end            reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    END             reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    ELSE            reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    CLOSE_PAR       reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .)
    AND_OR          shift and go to state 35

  ! AND_OR          [ reduce using rule 17 (bool_expression -> bool_expression AND_OR bool_expression .) ]


state 59

    (35) if -> IF OPEN_PAR bool_expression . CLOSE_PAR THEN statement possible_else END
    (17) bool_expression -> bool_expression . AND_OR bool_expression

    CLOSE_PAR       shift and go to state 68
    AND_OR          shift and go to state 35


state 60

    (25) num_expression -> OPEN_PAR num_expression CLOSE_PAR .

    PLUS            reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    MINUS           reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    TIMES           reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    DIVIDE          reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    POWER           reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    REL_OP          reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    IDENTIFIER      reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    IF              reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    WHILE           reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    OPEN_PAR        reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    NUM             reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    COLON           reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    BOOL            reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    NOT             reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    TO              reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    $end            reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    END             reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    ELSE            reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    CLOSE_PAR       reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)
    AND_OR          reduce using rule 25 (num_expression -> OPEN_PAR num_expression CLOSE_PAR .)


state 61

    (18) bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .

    AND_OR          reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    IDENTIFIER      reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    IF              reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    WHILE           reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    OPEN_PAR        reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    MINUS           reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    NUM             reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    COLON           reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    BOOL            reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    NOT             reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    TO              reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    $end            reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    END             reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    ELSE            reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)
    CLOSE_PAR       reduce using rule 18 (bool_expression -> OPEN_PAR bool_expression CLOSE_PAR .)


state 62

    (6) while -> WHILE OPEN_PAR bool_expression . CLOSE_PAR program END
    (17) bool_expression -> bool_expression . AND_OR bool_expression

    CLOSE_PAR       shift and go to state 69
    AND_OR          shift and go to state 35


state 63

    (25) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    CLOSE_PAR       shift and go to state 60
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33


state 64

    (28) num_expression -> COLON IDENTIFIER .

    PLUS            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    WHILE           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    END             reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)


state 65

    (25) num_expression -> OPEN_PAR num_expression . CLOSE_PAR
    (16) bool_expression -> num_expression . REL_OP num_expression
    (20) num_expression -> num_expression . PLUS num_expression
    (21) num_expression -> num_expression . MINUS num_expression
    (22) num_expression -> num_expression . TIMES num_expression
    (23) num_expression -> num_expression . DIVIDE num_expression
    (24) num_expression -> num_expression . POWER num_expression

    CLOSE_PAR       shift and go to state 60
    REL_OP          shift and go to state 34
    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    TIMES           shift and go to state 31
    DIVIDE          shift and go to state 32
    POWER           shift and go to state 33


state 66

    (19) bool_expression -> COLON IDENTIFIER .
    (28) num_expression -> COLON IDENTIFIER .

  ! reduce/reduce conflict for MINUS resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
  ! reduce/reduce conflict for CLOSE_PAR resolved using rule 19 (bool_expression -> COLON IDENTIFIER .)
    AND_OR          reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    IDENTIFIER      reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    IF              reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    WHILE           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    OPEN_PAR        reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    MINUS           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    NUM             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    COLON           reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    BOOL            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    NOT             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    TO              reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    $end            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    END             reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    ELSE            reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    CLOSE_PAR       reduce using rule 19 (bool_expression -> COLON IDENTIFIER .)
    REL_OP          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    PLUS            reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    TIMES           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    DIVIDE          reduce using rule 28 (num_expression -> COLON IDENTIFIER .)
    POWER           reduce using rule 28 (num_expression -> COLON IDENTIFIER .)

  ! MINUS           [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]
  ! CLOSE_PAR       [ reduce using rule 28 (num_expression -> COLON IDENTIFIER .) ]


state 67

    (29) func -> TO IDENTIFIER OPEN_PAR . opt_args CLOSE_PAR program END
    (30) opt_args -> . IDENTIFIER opt_args
    (31) opt_args -> . empty
    (38) empty -> .

    IDENTIFIER      shift and go to state 70
    CLOSE_PAR       reduce using rule 38 (empty -> .)

    opt_args                       shift and go to state 71
    empty                          shift and go to state 72

state 68

    (35) if -> IF OPEN_PAR bool_expression CLOSE_PAR . THEN statement possible_else END

    THEN            shift and go to state 73


state 69

    (6) while -> WHILE OPEN_PAR bool_expression CLOSE_PAR . program END
    (1) program -> . statement other_statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    bool_expression                shift and go to state 9
    program                        shift and go to state 74
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 70

    (30) opt_args -> IDENTIFIER . opt_args
    (30) opt_args -> . IDENTIFIER opt_args
    (31) opt_args -> . empty
    (38) empty -> .

    IDENTIFIER      shift and go to state 70
    CLOSE_PAR       reduce using rule 38 (empty -> .)

    opt_args                       shift and go to state 75
    empty                          shift and go to state 72

state 71

    (29) func -> TO IDENTIFIER OPEN_PAR opt_args . CLOSE_PAR program END

    CLOSE_PAR       shift and go to state 76


state 72

    (31) opt_args -> empty .

    CLOSE_PAR       reduce using rule 31 (opt_args -> empty .)


state 73

    (35) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN . statement possible_else END
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    bool_expression                shift and go to state 9
    statement                      shift and go to state 77
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 74

    (6) while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program . END

    END             shift and go to state 78


state 75

    (30) opt_args -> IDENTIFIER opt_args .

    CLOSE_PAR       reduce using rule 30 (opt_args -> IDENTIFIER opt_args .)


state 76

    (29) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR . program END
    (1) program -> . statement other_statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    program                        shift and go to state 79
    statement                      shift and go to state 2
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 77

    (35) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement . possible_else END
    (36) possible_else -> . ELSE statement
    (37) possible_else -> . empty
    (38) empty -> .

    ELSE            shift and go to state 81
    END             reduce using rule 38 (empty -> .)

    possible_else                  shift and go to state 80
    empty                          shift and go to state 82

state 78

    (6) while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .

    IDENTIFIER      reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    IF              reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    WHILE           reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    OPEN_PAR        reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    MINUS           reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    NUM             reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    COLON           reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    BOOL            reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    NOT             reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    TO              reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    $end            reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    END             reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)
    ELSE            reduce using rule 6 (while -> WHILE OPEN_PAR bool_expression CLOSE_PAR program END .)


state 79

    (29) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program . END

    END             shift and go to state 83


state 80

    (35) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else . END

    END             shift and go to state 84


state 81

    (36) possible_else -> ELSE . statement
    (2) statement -> . assign
    (3) statement -> . expression
    (4) statement -> . if
    (5) statement -> . while
    (7) assign -> . IDENTIFIER EQUALS expression
    (10) expression -> . num_expression
    (11) expression -> . bool_expression
    (12) expression -> . func
    (13) expression -> . call_func
    (35) if -> . IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END
    (6) while -> . WHILE OPEN_PAR bool_expression CLOSE_PAR program END
    (20) num_expression -> . num_expression PLUS num_expression
    (21) num_expression -> . num_expression MINUS num_expression
    (22) num_expression -> . num_expression TIMES num_expression
    (23) num_expression -> . num_expression DIVIDE num_expression
    (24) num_expression -> . num_expression POWER num_expression
    (25) num_expression -> . OPEN_PAR num_expression CLOSE_PAR
    (26) num_expression -> . MINUS num_expression
    (27) num_expression -> . NUM
    (28) num_expression -> . COLON IDENTIFIER
    (14) bool_expression -> . BOOL
    (15) bool_expression -> . NOT bool_expression
    (16) bool_expression -> . num_expression REL_OP num_expression
    (17) bool_expression -> . bool_expression AND_OR bool_expression
    (18) bool_expression -> . OPEN_PAR bool_expression CLOSE_PAR
    (19) bool_expression -> . COLON IDENTIFIER
    (29) func -> . TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END
    (34) call_func -> . IDENTIFIER opt_params

    IDENTIFIER      shift and go to state 7
    IF              shift and go to state 12
    WHILE           shift and go to state 14
    OPEN_PAR        shift and go to state 13
    MINUS           shift and go to state 15
    NUM             shift and go to state 16
    COLON           shift and go to state 17
    BOOL            shift and go to state 18
    NOT             shift and go to state 19
    TO              shift and go to state 20

    statement                      shift and go to state 85
    assign                         shift and go to state 3
    expression                     shift and go to state 4
    if                             shift and go to state 5
    while                          shift and go to state 6
    num_expression                 shift and go to state 8
    bool_expression                shift and go to state 9
    func                           shift and go to state 10
    call_func                      shift and go to state 11

state 82

    (37) possible_else -> empty .

    END             reduce using rule 37 (possible_else -> empty .)


state 83

    (29) func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .

    IDENTIFIER      reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    IF              reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    WHILE           reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    OPEN_PAR        reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    MINUS           reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    NUM             reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    COLON           reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    BOOL            reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    NOT             reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    TO              reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    $end            reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    END             reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)
    ELSE            reduce using rule 29 (func -> TO IDENTIFIER OPEN_PAR opt_args CLOSE_PAR program END .)


state 84

    (35) if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .

    IDENTIFIER      reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    IF              reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    WHILE           reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    OPEN_PAR        reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    MINUS           reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    NUM             reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    COLON           reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    BOOL            reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    NOT             reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    TO              reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    $end            reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    END             reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)
    ELSE            reduce using rule 35 (if -> IF OPEN_PAR bool_expression CLOSE_PAR THEN statement possible_else END .)


state 85

    (36) possible_else -> ELSE statement .

    END             reduce using rule 36 (possible_else -> ELSE statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for OPEN_PAR in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for NUM in state 7 resolved as shift
WARNING: shift/reduce conflict for COLON in state 7 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 7 resolved as shift
WARNING: shift/reduce conflict for NOT in state 7 resolved as shift
WARNING: shift/reduce conflict for TO in state 7 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 8 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAR in state 24 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 24 resolved as shift
WARNING: shift/reduce conflict for NUM in state 24 resolved as shift
WARNING: shift/reduce conflict for COLON in state 24 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 24 resolved as shift
WARNING: shift/reduce conflict for NOT in state 24 resolved as shift
WARNING: shift/reduce conflict for TO in state 24 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 24 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAR in state 26 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 26 resolved as shift
WARNING: shift/reduce conflict for NUM in state 26 resolved as shift
WARNING: shift/reduce conflict for COLON in state 26 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 26 resolved as shift
WARNING: shift/reduce conflict for NOT in state 26 resolved as shift
WARNING: shift/reduce conflict for TO in state 26 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 26 resolved as shift
WARNING: shift/reduce conflict for AND_OR in state 44 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 57 resolved as shift
WARNING: shift/reduce conflict for AND_OR in state 58 resolved as shift
WARNING: reduce/reduce conflict in state 43 resolved using rule (bool_expression -> COLON IDENTIFIER)
WARNING: rejected rule (num_expression -> COLON IDENTIFIER) in state 43
WARNING: reduce/reduce conflict in state 66 resolved using rule (bool_expression -> COLON IDENTIFIER)
WARNING: rejected rule (num_expression -> COLON IDENTIFIER) in state 66
